<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JS 101</title>
    <link rel="icon" type="image/webp" href="ic_logo/logo192.webp"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="theme-color" content="#051368"/>
    <meta name="description" content="JavaScript 101"/>
    <link rel="apple-touch-icon" href="ic_logo/ic_logo.svg"/>
    <link rel="manifest" href="./manifest.json"/>
    <link rel="stylesheet" type="text/css" href="styles/main.css">
</head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y6WJZG0J86"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-Y6WJZG0J86');
</script>

<body>
<noscript>You need to enable JavaScript to run this app.</noscript>
<h1 align="center">JavaScript 101</h1>
<div class="js_types_system_container">
    <img class="js_types_sun" src="images/js_logo.svg" alt="JavaScript logo"/>
    <ul class="js_types_container">
        <li class="js_type" style="animation-delay: -18s;">
            Undefined
            <div class="js_type_details">
                Для неприсвоенных значений неопределённый тип
                <br>
                typeof instance === "undefined"
            </div>
        </li>
        <li class="js_type" style="animation-delay: -16s;">
            Boolean
            <div class="js_type_details">
                Булев, Логический тип
                <br>
                typeof instance === "boolean"
            </div>
        </li>
        <li class="js_type" style="animation-delay: -14s;">
            Number
            <div class="js_type_details">
                Число
                <br>
                typeof instance === "number"
            </div>
        </li>
        <li class="js_type" style="animation-delay: -12s;">
            String
            <div class="js_type_details">
                Строка
                <br>
                typeof instance === "string"
            </div>
        </li>
        <li class="js_type" style="animation-delay: -10s;">
            BigInt
            <div class="js_type_details">
                Для целых чисел произвольной длины
                <br>
                typeof instance === "bigint"
            </div>
        </li>
        <li class="js_type" style="animation-delay: -8s;">
            Symbol
            <div class="js_type_details">
                Для гарантированно уникальных идентификаторов
                <br>
                typeof instance === "symbol"
            </div>
        </li>
        <li class="js_type" style="animation-delay: -6s;">
            Object
            <div class="js_type_details">
                Объект - структура, используемая не только для хранения данных, но и для создания других структур
                <br>
                typeof instance === "object"
            </div>
        </li>
        <li class="js_type" style="animation-delay: -4s;">
            Null
            <div class="js_type_details">
                Специальный примитив, используемый не только для данных, но и в качестве указателя на финальную точку в
                Цепочке Прототипов
                <br>
                typeof instance === "object"
            </div>
        </li>
        <li class="js_type" style="animation-delay: -2s;">
            Function
            <div class="js_type_details">
                Специальный случай, упрощающий определение типа для Функций, несмотря на то, что все функции
                конструктивно унаследованы от Object
                <br>
                typeof instance === "function"
            </div>
        </li>
    </ul>
</div>
<ul class="js_data_structures_container">
    Структуры данных
    <li class="js_data_structure_card" style="left: 4vmin;">
        <h2>Array</h2>
        Массивы являются спископодобными объектами, чьи прототипы содержат методы для операций обхода и изменения
        массива. Ни размер JavaScript-массива, ни типы его элементов не являются фиксированными. Поскольку размер
        массива может увеличиваться и уменьшаться в любое время, то нет гарантии, что массив окажется плотным. То есть,
        при работе с массивом может возникнуть ситуация, что элемент массива, к которому вы обратитесь, будет пустым и
        вернёт undefined.
    </li>
    <li class="js_data_structure_card" style="left: 8vmin;">
        <h2>LinkedList</h2>
        Связанный список - последовательная (Sequential) структура данных, где каждый узел состоит из двух частей:
        данных узла и указателя на следующий узел или на null, если следующего узла нет. Если у каждого узла есть только
        один указатель на другой узел (чаще всего называется next), то этот список считается односвязный (singly linked
        list); тогда как если у каждого узла есть две ссылки (обычно previous и next), то он считается двусвязный
        (doubly linked list).
    </li>
    <li class="js_data_structure_card" style="left: 12vmin;">
        <h2>Stack</h2>
        Стопка - последовательная (Sequential) структура данных, которая следует принципу LIFO (Last In First Out —
        последним вошел, первым вышел).
    </li>
    <li class="js_data_structure_card" style="left: 16vmin;">
        <h2>Queue</h2>
        Последовательная (Sequential) структура данных, которая следует принципу FIFO (First In First Out — первым
        вошел, первым вышел).
    </li>
    <li class="js_data_structure_card" style="left: 20vmin;">
        <h2>HashTable</h2>
        Хеш-таблица — это структура данных, которая строится по принципу ключ-значение. Из-за высокой скорости поиска
        значений по ключам, она используется в таких структурах, как Map, Dictionary и Object. Хеш-таблица имеет hash
        function, преобразующую ключи в список номеров, которые используются как имена (значения) ключей. Время поиска
        значения по ключу может достигать O(1). Одинаковые ключи должны возвращать одинаковые значения — в этом суть
        функции хэширования.
    </li>
    <li class="js_data_structure_card" style="left: 24vmin;">
        <h2>Graph</h2>
        Граф, также известный как сеть (Network), представляет собой коллекцию связанных между собой узлов.
    </li>
    <li class="js_data_structure_card" style="left: 28vmin;">
        <h2>Trees</h2>
        Деревья подобны связанным спискам, за исключением того, что каждый узел может иметь более одного дочернего узла,
        а каждый дочерний узел - не более одного родителя. В частности, для бинарного дерева поиска дочерних узлов может
        быть только два, причем значение левого меньше значения родителя, а правого больше.
    </li>
    <li class="js_data_structure_card" style="left: 32vmin;">
        <h2>Trie</h2>
        Префиксное дерево — это разновидность поискового дерева. Данные в нем сохраняются последовательно (шаг за шагом)
        — каждый узел дерева представляет собой один шаг. Префиксное дерево используется в словарях, поскольку
        существенно ускоряет поиск.
    </li>
</ul>
<section class="js_algorithms_container">
    Популярные алгоритмы
    <div class="algorithms_tabs">
        <input type="radio" name="algorithms_tab_button" id="graphs_tab_button" value="" checked>
        <label for="graphs_tab_button">Графы</label>
        <input type="radio" name="algorithms_tab_button" id="sort_tab_button" value="">
        <label for="sort_tab_button">Сортировка</label>
        <input type="radio" name="algorithms_tab_button" id="string_tab_button" value="">
        <label for="string_tab_button">Строки</label>
        <input type="radio" name="algorithms_tab_button" id="other_tab_button" value="">
        <label for="other_tab_button">Прочие</label>

        <article id="graphs_tab" class="js_algorithms_article">
            Articulation points: Вершина в неориентированном связном графе является точкой сочленения (или вырезанной
            вершиной), если ее удаление (и проходящие через нее ребра) разъединяет граф. Точки сочленения представляют
            собой уязвимости в подключенной сети - единые точки, отказ которых разделил бы сеть на 2 или более
            отключенных компонента. Полезно для проектирования надежных сетей.
            <br>
            <br>
            Breadth-first search: Поиск в ширину (BFS) - это алгоритм для обхода или поиска структур данных в виде
            дерева или графа. Он начинается с корня дерева (или некоторого произвольного узла графа, иногда называемого
            "ключом поиска") и сначала исследует соседние узлы, прежде чем перейти к соседям следующего уровня.
            <br>
            <br>
            Depth-first search: Поиск в глубину (DFS) - это алгоритм обхода или поиска структур данных в виде дерева или
            графа. Каждый начинает с корня (выбирая произвольный узел в качестве корня в случае графа) и исследует,
            насколько это возможно, каждую ветвь перед отслеживанием с возвратом.
            <br>
            <br>
            Dijkstra: Алгоритм поиска кратчайших путей между узлами в графе, которые могут представлять, например,
            дорожные сети.
            <br>
            <br>
            Bellman-Ford: Алгоритм, который вычисляет кратчайшие пути от одной исходной вершины ко всем остальным
            вершинам взвешенного графа. Он медленнее, чем алгоритм Дейкстры для той же проблемы, но более универсален,
            поскольку он способен обрабатывать графы, в которых некоторые веса ребер являются отрицательными числами.
            <br>
            <br>
            Floyd-Warshall: Алгоритм поиска кратчайших путей во взвешенном графе с положительными или отрицательными
            весами ребер (но без отрицательных циклов). Одно выполнение алгоритма найдет длины (суммарные веса)
            кратчайших путей между всеми парами вершин.
            <br>
            <br>
            Eulerian path: В теории графов эйлеров след (или эйлеров путь) - это след в конечном графе, который посещает
            каждое ребро ровно один раз. Точно так же эйлеров контур или эйлеров цикл - это эйлеров след, который
            начинается и заканчивается в одной и той же вершине.
            <br>
            <br>
            Prim: Алгоритм Прима - это жадный алгоритм, который находит минимальное охватывающее дерево для взвешенного
            неориентированного графа. Алгоритм работает, строя это дерево по одной вершине за раз, из произвольной
            начальной вершины, на каждом шаге добавляя самое дешевое возможное соединение из дерева в другую вершину.
        </article>
        <article id="sorting_tab" class="js_algorithms_article">
            Bubble sort: Сортировка пузырьков, иногда называемая сортировкой по убыванию, представляет собой простой
            алгоритм сортировки, который многократно проходит через список для сортировки, сравнивает каждую пару
            соседних элементов и меняет их местами, если они находятся в неправильном порядке (по возрастанию или по
            убыванию). Прохождение по списку повторяется до тех пор, пока не перестанут использоваться свопы, что
            указывает на то, что список отсортирован.
            <br>
            <br>
            Counting sort: Подсчетная сортировка - это алгоритм сортировки коллекции объектов по ключам, которые
            являются небольшими целыми числами; то есть это целочисленный алгоритм сортировки. Он работает путем
            подсчета количества объектов, которые имеют каждое отдельное значение ключа, и использования арифметических
            операций с этими счетчиками для определения позиций каждого значения ключа в выходной последовательности.
            Время его работы линейно зависит от количества элементов и разницы между максимальным и минимальным
            значениями ключа, поэтому он подходит для прямого использования только в ситуациях, когда вариация ключей не
            намного превышает количество элементов. Однако он часто используется в качестве подпрограммы в другом
            алгоритме сортировки, Radix sort, который может более эффективно обрабатывать большие ключи.
            <br>
            <br>
            Heap sort : Алгоритм сортировки, основанный на сравнении. Heapsort можно рассматривать как улучшенную
            сортировку выбора: как и этот алгоритм, он делит входные данные на отсортированную и несортированную области
            и итеративно сжимает несортированную область, извлекая самый большой элемент и перемещая его в
            отсортированную область. Улучшение состоит в использовании структуры данных кучи, а не поиска в линейном
            времени для поиска максимума.
            <br>
            <br>
            Insertion sort: Сортировка вставкой - это простой алгоритм сортировки, который строит окончательный
            отсортированный массив (или список) по одному элементу за раз. Он намного менее эффективен для больших
            списков, чем более продвинутые алгоритмы, такие как быстрая сортировка, heapsort или сортировка слиянием.
            <br>
            <br>
            Merge sort: Сортировка слиянием (также обычно обозначаемая как сортировка слиянием) - это эффективный
            универсальный алгоритм сортировки, основанный на сравнении. Большинство реализаций производят стабильную
            сортировку, что означает, что реализация сохраняет порядок ввода одинаковых элементов в отсортированном
            выводе.
            <br>
            <br>
            Quick sort: Быстрая сортировка - это алгоритм «разделяй и властвуй». Быстрая сортировка сначала делит
            большой массив на два меньших подмассива: нижние элементы и высокие элементы. Затем Быстрая сортировка может
            рекурсивно сортировать подмассивы.
            <br>
            <br>
            Radix sort: Это алгоритм сортировки несравнительных целых чисел, который сортирует данные с целочисленными
            ключами путем группировки ключей по отдельным цифрам, которые имеют одинаковую значащую позицию и значение.
            Позиционная нотация обязательна, но поскольку целые числа могут представлять строки символов (например,
            имена или даты) и специально отформатированные числа с плавающей запятой, сортировка по основанию не
            ограничивается целыми числами.
            <br>
            <br>
            Selection sort: Сортировка выбора - это алгоритм сортировки, в частности сортировка на месте сравнения. Он
            имеет временную сложность O(n2), что делает его неэффективным для больших списков и, как правило, работает
            хуже, чем аналогичная сортировка вставкой. Сортировка по выбору отличается своей простотой и имеет
            преимущества в производительности по сравнению с более сложными алгоритмами в определенных ситуациях,
            особенно когда вспомогательная память ограничена.
            <br>
            <br>
            Shellsort: Шеллсорт, также известный как сортировка Шелла или метод Шелла, является сортировкой на месте
            сравнения. Это можно рассматривать как обобщение сортировки путем обмена (пузырьковая сортировка) или
            сортировки путем вставки (сортировка вставкой). Метод начинается с сортировки пар элементов на большом
            расстоянии друг от друга, а затем постепенного уменьшения разрыва между сравниваемыми элементами.
        </article>
        <article id="strings_tab" class="js_algorithms_article">
            Hamming distance: Расстояние Хэмминга между двумя строками одинаковой длины - это количество позиций, в
            которых соответствующие символы различаются. Другими словами, он измеряет минимальное количество замен,
            необходимых для преобразования одной строки в другую, или минимальное количество ошибок, которые могли бы
            преобразовать одну строку в другую. В более общем контексте расстояние Хэмминга - это одна из нескольких
            строковых метрик для измерения расстояния редактирования между двумя последовательностями.
            <br>
            <br>
            Knuth-Morris-Pratt: Алгоритм поиска строки Кнута – Морриса – Пратта ищет вхождения слова в текстовой строке
            используя наблюдение, что при возникновении несоответствия само слово содержит достаточно информации, чтобы
            определить, где следующее совпадение может начаться, минуя повторную проверку ранее сопоставленных символов.
            <br>
            <br>
            Levenshtein distance: Расстояние Левенштейна - это строковая метрика для измерения разницы между двумя
            последовательностями. Неформально расстояние Левенштейна между двумя словами - это минимальное количество
            односимвольных правок (вставок, удалений или замен), необходимых для преобразования одного слова в другое.
            <br>
            <br>
            Longest common substring: Находит самую длинную строку (или строки), которая является подстрокой (или
            являются подстроками) из двух или более строк. "Rabin-Karp" : "Алгоритм Карпа – Рабина - это алгоритм поиска
            строки, который использует хеширование для поиска любой из набора строк шаблонов в тексте.
            <br>
            <br>
            Z-algorithm: Z-алгоритм находит вхождения слова в текстовой строке за линейное время.
        </article>
        <article id="other_tab" class="js_algorithms_article">
            Euclidean algorithm: Алгоритм Евклида - это эффективный метод вычисления наибольшего общего делителя двух
            чисел.
            <br>
            <br>
            Horner method: Схема Горнера - алгоритм вычисления значения многочлена, записанного в виде суммы мономов
            (одночленов), при заданном значении переменной.
            <br>
            <br>
            Binary search: Двоичный поиск, также известный как поиск с половинным интервалом, логарифмический поиск или
            двоичный поиск, представляет собой алгоритм поиска, который находит позицию целевого значения в
            отсортированном массиве.
            <br>
            <br>
            Interpolation search: Поиск с интерполяцией - это алгоритм поиска ключа в массиве, который упорядочен по
            числовым значениям.
            <br>
            <br>
            Jump search: Подобно двоичному поиску, поиск с переходом (или поиск по блоку) представляет собой алгоритм
            поиска отсортированных массивов. Основная идея состоит в том, чтобы проверять меньшее количество элементов
            (чем линейный поиск), перескакивая вперед на фиксированные шаги или пропуская некоторые элементы вместо
            поиска всех элементов.
            <br>
            <br>
            Linear search: Линейный поиск или последовательный поиск - это метод поиска целевого значения в списке. Он
            последовательно проверяет каждый элемент списка на предмет целевого значения, пока не будет найдено
            совпадение или пока не будут найдены все элементы. Линейный поиск выполняется в худшем случае за линейное
            время и производит не более n сравнений, где n - длина списка.
        </article>
    </div>
</section>
<br>
<footer>
    Закодила Sasha Inverse; Благодаря вдохновению от dcVersus
</footer>
 <script>
        if('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service_worker.js')
                    .then((reg) => console.log('Success: ', reg.scope))
                    .catch((err) => console.log('Failure: ', err));
            })
        }
    </script>
</body>
</html>